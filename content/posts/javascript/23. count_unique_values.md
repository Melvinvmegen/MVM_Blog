---
id: 23
title: "Counting Unique Values in Sorted Arrays"
subtitle: "Efficient Algorithms for Unique Element Counting"
description: "Explore multiple approaches to count unique values in sorted arrays, from hash-based solutions to optimal in-place pointer techniques with O(n) time and O(1) space complexity."
category: "JavaScript"
last_updated: "19 Août 2025"
---

# Counting Unique Values in Sorted Arrays

## The problem

Count the number of unique values in a **sorted** array efficiently. This is a fundamental problem that demonstrates important algorithmic techniques.

**Example**:
```javascript
countUniqueValues([1,1,2,3,3,4,5,5,5,6]) // Returns 6
```

## Approach 1: Set Conversion (Simplest for Unsorted)

**Most readable solution** using JavaScript's built-in Set:

```js
function countUniqueValues(arr) {
  return new Set(arr).size;
}
```

## Approach 2: Hash Map Solution

```js
function countUniqueValues(arr) {
  if (!arr.length) return 0;

  const seen = {};
  for (const num of arr) {
    seen[num] = true; // Mark value as seen
  }
  return Object.keys(seen).length;
};
```

**Explanation:**
1. Uses an object **uniques** to track seen values
2. Return the amount of keys

### Performance analysis
- Time: **O(n)** - Single pass through the array
- Space: **O(n)** - Stores all unique values in worst case

## Approach 3: Two-Pointer Technique

```js
function countUniqueValues(arr) {
  if (!arr.length) return 0;
  let i = 0;
  for (let j = 1; j < arr.length; j++) {
    if (arr[i] !== arr[j]) {
      i++;
      arr[i] = arr[j];
    }
  }

  return i + 1;
}
```

**Explanation:**
1. Create a copy of the array to prevent override
2. Pointer i tracks the last unique value's position
3. Pointer j scans ahead for new values
4. When arr[j] differs from arr[i], it's a new unique value
5. Copy it to position i+1 to remove duplicates
6. Increment i
7. First i+1 elements become all unique values

### Performance analysis
- Time: **O(n)** Single pass through array
- Space: **O(1)** We mutate the array

### Why Sorting Matters
The two-pointer technique requires sorted input because it relies on these key properties:
1. **Duplicate Grouping:** Identical values are consecutive in sorted arrays
2. **Single Pass Detection:** New values appear immediately after all duplicates
3. **In-Place Modification:** Allows O(1) space complexity by overwriting duplicates

**Without sorting**, duplicates may be scattered, breaking the algorithm's core logic.

## Performance Comparison

|  Approach            | Time Complexity | Space Complexity | Modifies Input | Works with Unsorted | Best Use Case                        |
|---------------------|-----------------|------------------|----------------|---------------------|-----------------------------------    |
| Two-Pointer         | O(n)            | O(1)             | ✅ Yes         | ❌ No               | Large sorted arrays                   |
| Hash Map            | O(n)            | O(n)             | ❌ No          | ✅ Yes              | Unsorted arrays, general purpose      |
| Set Conversion      | O(n)            | O(n)             | ❌ No          | ✅ Yes              | Small/medium arrays, readability      |
| Sort + Two-Pointer  | O(n log n)      | O(1)*            | ✅ Yes         | ✅ (after sort)     | Large unsorted arrays (if modifiable) |

*Assumes in-place sorting. If creating a new sorted array, space becomes O(n).

## Conclusion

That's it if for the counting unique values in arrays algorithm I hope you learned as much as I did and if you have any questions or suggestions please hit me up in the comments!
