---
id: 3
title: "Clean JavaScript code"
subtitle: "Les meilleures pratiques pour √©crire du code JS maintenable, √©volutif et lisible."
description: "Dans cet article, je vous pr√©senterai les meilleures pratiques √©tablies pour √©crire un code JavaScript propre et lisible, notamment les conventions de nommage, l'utilisation des fonctionnalit√©s ES6, le fait d'√©viter les variables globales, de garder les fonctions aussi concices que possible, etc."
category: "Javascript"
last_updated: "20 d√©cembre 2022"
---

## Qu'est-ce qu'un code propre ?

C'est une question vraiment controvers√©e et j'aimerais dire qu'il y a beaucoup de r√©ponses √† ce sujet, mais comme id√©e g√©n√©rale le terme de **Clean code** d√©signe un code qui est facile √† lire, √† comprendre et √† maintenir. **Comment reconna√Ætre un code propre ?** Il doit √™tre bien organis√©, bien structur√©, facile √† modifier, √† tester et √† d√©buguer. Suivre les meilleures pratiques et les normes  √©tabliesde l'industrie vous permet d'√©crire un code libre bloat, de redondance et de complexit√©. Permettez-moi de partager avec vous certaines de ces meilleures pratiques.

## Conventions de nommage
Bien que cela puisse sembler √©l√©mentaire, accorder une attention particuli√®re aux noms des variables peut √™tre crucial pour rendre le code lisible et facile √† maintenir. L'utilisation de noms descriptifs et significatifs pour les variables, les fonctions et les objets peut contribuer √† r√©duire la charge cognitive n√©cessaire pour comprendre et travailler avec le code. √âviter les abr√©viations et autres raccourcis peut √©galement contribuer √† am√©liorer la clart√© et la lisibilit√© du code.

Par exemple, au lieu d'utiliser un nom de variable vague comme **data**, envisagez d'utiliser un nom plus descriptif qui refl√®te les donn√©es r√©elles repr√©sent√©es, comme **customerData** ou encore **productList**.

```js
// ‚ùå Mauvais exemple
const d = [1, 2, 3];

// ‚úÖ Bon exemple
const data = [1, 2, 3];

// ‚ùå Mauvais exemple
function f(a) {
  return a + 1;
}

// ‚úÖ Bon exemple
function addOne(number) {
  return number + 1;
}
```

## Utiliser les fonctionnalit√©s ES6
**ES6**, la derni√®re version de JavaScript, a introduit plusieurs fonctionnalit√©s qui peuvent grandement am√©liorer la propret√© et la clart√© du code JavaScript. Pour n'en citer que quelques-unes, la **destructuration** permet aux d√©veloppeurs d'extraire plus facilement des valeurs de tableaux ou d'objets, les **arrow function** offrent une syntaxe plus concise pour d√©finir des fonctions, et les **template literals** permettent d'int√©grer des expressions dans des **string literals** sans avoir √† concat√©ner ou √† √©chapper des caract√®res.

```js
// Const and let declarations
const PI = 3.14;
let name = 'John Doe';

// Template literals
const message = `Hello ${name}!`;

// Arrow functions
const square = (x) => x * x;

// Default parameters
const add = (a, b = 0) => a + b;

// Destructuring
const data = [1, 2, 3];
const [first, second, third] = data;

const person = {
  firstName: 'John',
  lastName: 'Doe'
};
const { firstName, lastName } = person;

// Spread operator
const lotus = [1, 2, 3];
const numbers = [...lotus, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]

// Rest parameters
const sum = (...numbers) => numbers.reduce((total, current) => total + current, 0); // 21

// Object literals
const firstName = 'John';
const lastName = 'Doe';
const person = { firstName, lastName };

// Class syntax
class Person {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  }
}
```
## √âvitez les variables globales
**Les variables globales** peuvent poser plusieurs probl√®mes, notamment des conflits de noms et une capacit√© de maintenance r√©duite. Elles doivent g√©n√©ralement √™tre √©vit√©es, sauf si l'objectif est de partager cette variable √† travers l'application, comme pour les **variables d'env**. Pour organiser et g√©rer le code plus efficacement, envisagez d'utiliser plut√¥t des modules. Les modules permettent d'encapsuler du code et des donn√©es associ√©s, ce qui minimise le risque de conflits de noms et d'effets de bords inattendus et facilite la maintenance et la mise √† jour du code.

```js
// ‚ùå Mauvais exemple
counter = 0;

function incrementCounter() {
  counter++;
}

// ‚úÖ Bon exemple
let counter = 0;

function incrementCounter() {
  counter++;
}

// ‚úÖ Meilleur exemple
function createCounter() {
  let counter = 0;

  return {
    increment: function () {
      counter++;
    },
    getCount: function () {
      return counter;
    }
  };
}

const counter = createCounter();
```

- **Mauvais exemple** : la variable counter est d√©clar√©e comme une variable globale, ce qui peut provoquer des conflits de noms et rendre le code plus difficile √† maintenir. 
- **Bon exemple** : la variable est d√©clar√©e √† l'aide du mot cl√© **let**, ce qui en fait une variable locale et √©vite les conflits de noms.
- **Meilleur exemple** : la variable est encapsul√©e dans une fonction, ce qui cr√©e un **closure**. De cette fa√ßon, la variable n'est pas accessible de l'ext√©rieur de la fonction, ce qui la rend vraiment priv√©e et √©vite tout conflit de nom.

## Gardez des fonctions concices
Il est important que vos fonctions soient concices et centr√©es sur une seule responsabilit√©. En d√©composant une logique complexe en fonctions plus concices, vous pouvez augmenter la lisibilit√© de votre code et le rendre plus facile √† comprendre. Les fonctions concices sont souvent plus r√©utilisables et plus faciles √† tester, ce qui peut vous faire gagner du temps et des efforts √† long terme.

**Souvenez-vous toujours que les fonctions ne doivent faire qu'une seule chose et la faire bien.**

```js
// ‚ùå Mauvais exemple
function calculateOrderTotal(items, shippingMethod, discount) {
  let subtotal = 0;
  for (const item of items) {
    subtotal += item.price * item.quantity;
  }

  let shippingCost = 0;
  if (shippingMethod === 'standard') {
    shippingCost = subtotal * 0.1;
  } else if (shippingMethod === 'express') {
    shippingCost = subtotal * 0.2;
  }

  let discountAmount = 0;
  if (discount) {
    discountAmount = subtotal * discount;
  }

  return subtotal + shippingCost - discountAmount;
}

// ‚úÖ Bon exemple
function calculateSubtotal(items) {
  let subtotal = 0;
  for (const item of items) {
    subtotal += item.price * item.quantity;
  }
  return subtotal;
}

function calculateShippingCost(subtotal, shippingMethod) {
  let shippingCost = 0;
  if (shippingMethod === 'standard') {
    shippingCost = subtotal * 0.1;
  } else if (shippingMethod === 'express') {
    shippingCost = subtotal * 0.2;
  }
  return shippingCost;
}

function calculateDiscountAmount(subtotal, discount) {
  let discountAmount = 0;
  if (discount) {
    discountAmount = subtotal * discount;
  }
  return discountAmount;
}

function calculateOrderTotal(items, shippingMethod, discount) {
  const subtotal = calculateSubtotal(items);
  const shippingCost = calculateShippingCost(subtotal, shippingMethod);
  const discountAmount = calculateDiscountAmount(subtotal, discount);
  return subtotal + shippingCost - discountAmount;
}
```

- **Mauvais exemple**, la fonction calculateOrderTotal fait trop de choses. Il est difficile de comprendre ce qu'elle fait sans lire chaque ligne.

- **Bon exemple**, le code est refactoris√© en fonctions plus petites et plus faciles √† g√©rer. Chaque fonction a une seule responsabilit√©, ce qui rend le code plus facile √† comprendre, √† tester et √† maintenir.

## Utilisez le linting
Le linting est un outil qui peut am√©liorer la qualit√© de votre code. Il v√©rifie les erreurs potentielles, les bugs et les regressions pour s'assurer que votre code respecte les meilleures pratiques et conventions √©tablies. L'utilisation d'un outil de linting comme **ESLint**, vous aide √† garder votre code propre, maintenable, et √† attraper les erreurs avant qu'elles ne causent de probl√®mes. 

Voici un exemple simple de la fa√ßon dont vous pouvez utiliser **ESLint** pour am√©liorer votre code :

```sh
npm install eslint --save-dev
```

Cr√©ez un fichier nomm√© **.eslintrc** √† la racine de votre projet et ajoutez la configuration suivante :

```json
// .eslintrc
{
  "extends": "eslint:recommended",
  "rules": {
    "no-console": "off"
  }
}
```

Maintenant vous pouvez ex√©cuter **ESLint** sur votre code en utilisant la commande suivante :

```sh
npx eslint your-file.js
```

```js
// ‚ùå Code original
const name = 'John Doe';
console.log('Hello, ' + name);

// ‚úÖ Code corrig√©
const name = 'John Doe';
console.log(`Hello, ${name}`);
```
Aussi aga√ßant que cela puisse para√Ætre au d√©but avec toutes ces lignes rouges qui apparaissent, cela garantit que votre code est plus facile √† comprendre et √† maintenir, √† la fois pour vous et pour les autres d√©veloppeurs qui travailleront sur le projet, et croyez-moi, ils vous en remercieront.

## √âvitez les nombres magiques
Les nombres magiques sont des nombres utilis√©s dans le code sans contexte ni explication. Une meilleure approche consiste √† utiliser des noms de variables descriptifs pour repr√©senter ces valeurs.
Voici un exemple d'utilisation de variables descriptives pour √©viter les nombres magiques en JavaScript :
    
```js
// ‚ùå Mauvais exemple
function calculateTax(amount) {
  return amount * 0.2; // Que repr√©sente 0,2 ?
}

// ‚úÖ Bon exemple
const TAX_RATE = 0.2;

function calculateTax(amount) {
  return amount * TAX_RATE; // Ce que fait le calcul est bien plus clair
}
```

## Suivre le principe de la responsabilit√© unique
Le principe de responsabilit√© unique (**PRU**) est un principe fondamental du d√©veloppement logiciel qui stipule que chaque module, classe ou fonction doit avoir une responsabilit√© unique et bien d√©finie.

Prenons un exemple de **PRU** :

```js
class User {
  constructor(name, email, password) {
    this.name = name;
    this.email = email;
    this.password = password;
  }

  getName() {
    return this.name;
  }

  getEmail() {
    return this.email;
  }

  setPassword(password) {
    this.password = password;
  }

  sendEmail() {
    // code to send an email to the user
  }
}
```

Ici, la classe **User** a une responsabilit√© unique et bien d√©finie : g√©rer les informations d'un utilisateur.
Les m√©thodes **getName** et **getEmail** r√©cup√®rent respectivement le nom et l'email de l'utilisateur. La m√©thode **setPassword** met √† jour le mot de passe de l'utilisateur et la m√©thode **sendEmail** envoie comme son nom l'indique un email √† l'utilisateur.

Chaque m√©thode fait exactement ce qu'elle indique, elles ne se chevauchent pas et n'ont pas de responsabilit√©s multiples.

## √âcrire des tests
Lorsque vous √©crivez du code, vous voulez qu'il fonctionne correctement et qu'il ne p√®te pas de mani√®re inattendue lors du d√©ploiement en production. C'est l√† que les tests entrent en jeu. Consid√©rez-les comme un moyen de rev√©rifier votre travail et de vous assurer que votre code fait ce qu'il est cens√© faire.

Lorsque vous √©crivez des tests, veillez √† couvrir toutes les parties importantes de votre code. Cela inclut les situations normales, mais aussi les cas edge case o√π les choses peuvent ne pas fonctionner comme pr√©vu. Vous voulez √©galement tester ce qui se passe lorsque quelque chose ne va pas, comme lorsqu'un utilisateur saisit une mauvaise entr√©e ou lorsque votre API est down pour une raison quelconque.

En prenant le temps d'√©crire de bons tests, vous pouvez d√©tecter les erreurs et les bugs avant le d√©ploiement. Cela signifie que vous pouvez les corriger avant qu'ils ne deviennent des probl√®mes plus importants en cours de route. De plus, avec de bons tests, vous pouvez apporter des modifications et des mises √† jour √† votre code avec plus de confiance, en sachant que vous n'introduisez pas de nouveaux probl√®mes ou ne cassez pas ce qui fonctionne d√©j√†.

## Utilisez des messages d'erreur descriptifs
Lorsque nous programmons, nous faisons tous des erreurs et rencontrons des probl√®mes avec notre code. Cependant, avec l'aide des messages d'erreur, nous pouvons rapidement identifier et r√©soudre ces probl√®mes. 

Il est essentiel de cr√©er des messages d'erreur clairs et informatifs, expliquant la cause de l'erreur et fournissant des conseils sur la fa√ßon de la corriger. Cela peut nous faire gagner beaucoup de temps et de frustration √† long terme en nous aidant √† diagnostiquer et √† r√©soudre rapidement tout probl√®me survenant dans notre code. Prenez donc toujours le temps de r√©diger des messages d'erreur descriptifs qui peuvent rendre le processus de d√©buggage plus facile √† g√©rer et moins stressant.

```js
try {
  // code susceptible d'entra√Æner une erreur
  if (someCondition) {
    throw new Error("Invalid argument: someCondition must be true");
  }
} catch (error) {
  console.error(error.message);
}
```

Dans cet exemple, nous utilisons un bloc try-catch pour g√©rer les erreurs. Si le code √† l'int√©rieur du bloc try d√©clenche une erreur, le message d'erreur est attrap√© et montr√© dans la console √† l'aide de console.error(). 

Ici, le message d'erreur comprend la description **"Invalid argument : someCondition must be true "**, qui fournit suffisamment d'informations pour aider le d√©veloppeur √† comprendre la cause de l'erreur et √† la corriger.

*En outre, cela peut vous permettre de trouver la ligne du bug dans votre code si vous n'avez pas partag√© vos sourcemaps.*

De plus, si notre code est utilis√© par d'autres personnes, le fait de fournir des messages d'erreur descriptifs peut am√©liorer l'exp√©rience globale de l'utilisateur en l'aidant √† comprendre rapidement ce qui n'a pas fonctionn√©, ce qui offre une meilleure exp√©rience utilisateur et r√©duit la frustration et la confusion.

## Refactorisez r√©guli√®rement

**Le refactoring est le processus qui consiste √† am√©liorer la structure interne de votre code sans en changer le comportement.** 

√Ä mesure que votre code se d√©veloppe et change au fil du temps, il peut devenir plus complexe et plus difficile √† maintenir. 
Le refactoring peut contribuer √† am√©liorer les performances de votre code, √† r√©duire les bugs, les erreurs, √† faciliter la compr√©hension et la modification du code pour vous et les autres d√©veloppeurs √† l'avenir.

Par exemple, supposons que vous ayez un bout de code qui est devenu difficile √† g√©rer et √† comprendre :

```js
function calculateSum(numbers) {
  let sum = 0;
  for (let i = 0; i < numbers.length; i++) {
    sum += numbers[i];
  }
  return sum;
}
```

Ce code calcule la somme d'un array de nombres. Au fil du temps, cependant, le code peut devenir plus difficile √† maintenir √† mesure que le nombre de responsabilit√©s ou la complexit√© du code augmente.

Pour rem√©dier √† cela, nous pouvons remanier le code en utilisant **reduce** :

```js
function calculateSum(numbers) {
  return numbers.reduce((sum, number) => sum + number, 0);
}

```
## Conclusion
L'√©criture d'un code propre et lisible est essentielle pour produire des logiciels de qualit√©. En suivant les bonnes pratiques mentionn√©es ci-dessus, telles que la bri√®vet√© des fonctions et leur focalisation sur une seule responsabilit√©, l'utilisation de noms de variables et de fonctions descriptifs, l'√©vitement des nombres magiques et l'utilisation de messages d'erreur, votre code sera plus facile √† maintenir, plus √©volutif et plus facile √† comprendre.

Il est important de se rappeler que l'√©criture d'un code propre n'est pas une t√¢che ponctuelle, mais un processus continu qui n√©cessite de la pratique et de la discipline. En vous exer√ßant √† √©crire du code propre, vous trouverez plus facile de maintenir et de d√©velopper votre base de code existante, ce qui vous permettra d'√©conomiser du temps et des efforts √† long terme. En am√©liorant continuellement la qualit√© de votre code, vous pouvez produire des logiciels fiables, efficaces et faciles √† utiliser.

Continuez √† faire du bon travail et bon codage ! üöÄ